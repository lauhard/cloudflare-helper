{"version":3,"sources":["../src/cloudflare-base.ts","../src/cloudflare-helper.ts"],"names":[],"mappings":"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","file":"index.js","sourcesContent":["import { CloudflareHelper } from './types';\n\n/**\n * Base class for Cloudflare Workers integrations\n * Provides single point of access to Cloudflare platform APIs\n */\nexport class CloudflareBase {\n    protected platform: Readonly<CloudflareHelper.Platform>;\n    \n    constructor(platform: Readonly<CloudflareHelper.Platform>) {\n        this.platform = platform;\n    }\n\n    /**\n     * Get the platform object - this contains the Cloudflare Workers environment\n     * @returns The readonly platform object\n     */\n    protected getPlatform(): Readonly<CloudflareHelper.Platform> {\n        return this.platform;\n    }\n\n    /**\n     * Get specific binding from environment\n     * @param name - Name of the binding\n     * @returns The binding value or null if not found\n     */\n    protected getBinding<T>(name: string): T | null {\n        const env = this.getEnv();\n        if (name in env) {\n            return env[name] as T;\n        }\n        return null;\n    }\n    \n    /**\n     * Get the Cloudflare Workers environment object\n     * @returns The environment object containing bindings\n     */\n    protected getEnv(): CloudflareHelper.Platform['env'] {\n        return this.platform.env;\n    }\n\n    /**\n     * Get the execution context for waitUntil and passThroughOnException\n     * @returns The execution context\n     */\n    protected getContext(): CloudflareHelper.Platform['ctx'] {\n        return this.platform.ctx;\n    }\n\n    /**\n     * Get the default cache from Cloudflare Workers\n     * @returns The default cache instance\n     */\n    protected getCacheDefault(): Cache {\n        return this.platform.caches.default;\n    }\n\n    /**\n     * Get the Cloudflare request properties\n     * @returns The cf properties from the request\n     */\n    protected getCfProperties(): CloudflareHelper.Platform['cf'] {\n        return this.platform.cf;\n    }\n\n    /**\n     * Get the cache storage interface\n     * @returns The caches object containing named caches and default cache\n     */\n    protected getCacheStorage(): CloudflareHelper.Platform['caches'] {\n        return this.platform.caches;\n    }\n\n    /**\n     * Get the Cloudflare Workers context functions\n     * @returns Object with waitUntil and passThroughOnException functions\n     */\n    protected getExecutionContext(): CloudflareHelper.Platform['context'] {\n        return this.platform.context;\n    }\n}","\n/// <reference types=\"@cloudflare/workers-types\" />\nimport { CloudflareBase } from './cloudflare-base';\nimport { CloudflareHelper } from './types';\n\n\n\n\n/**\n * Cloudflare Cache Response Helper\n * This class provides methods to interact with the Cloudflare cache.\n */\nexport class CFCacheResponse extends CloudflareBase {\n    #cache: Cache;\n\n    constructor(platform: Readonly<CloudflareHelper.Platform>) {\n        super(platform);\n\n        // Access default cache using base class method\n        this.#cache = this.getCacheDefault();\n    }\n\n    /**\n     * Builds a cache key for the given request.\n     * @param request The request to build the cache key for.\n     * @param normalizeKey Optional function to normalize the cache key.\n     * @returns The cache key as a Request object.\n     */\n    private buildCacheKey(request: Request, normalizeKey?: (url: URL) => URL): Request {\n        // Guard: cache only GET and HEAD requests otherwise return safe path\n        if (request.method !== 'GET' && request.method !== 'HEAD') {\n            return request;\n        }\n\n        // Create url from request\n        const cacheURL = new URL(request.url);\n\n        // Normalize the cacheURL if normalizeKey function is provided\n        const normalizedURL = normalizeKey ? normalizeKey(cacheURL) : cacheURL;\n\n        // Assertion: origin must be the same\n        if (cacheURL.origin !== normalizedURL.origin) {\n            throw new Error('Cache key origin must match request origin');\n        }\n\n        // Return new Request cloned from original request with normalized URL        \n        return new Request(normalizedURL.toString(), request);\n    }\n\n    /**\n     * Create a new Response with updated headers\n     * The new Response has to be created to make headers mutable\n     * @param response response to update\n     * @param headers headers to set on the new Response\n     * @returns new Response with updated headers\n     */\n    private updateHeaders(response: Response, headers: Record<string, string>) {\n        const updatedHeaders = new Headers(response.headers);\n        for (const [key, value] of Object.entries(headers)) {\n            updatedHeaders.set(key, value);\n        }\n        // Make headers mutable by creating a new Response\n        return new Response(response.body, {\n            status: response.status,\n            statusText: response.statusText,\n            headers: updatedHeaders\n        });\n    }\n\n    /**\n     * Matches a request in the cache and returns the cached response if found\n     * @param request The request to match in the cache\n     * @param cacheOptions Optional cache options for key normalization\n     * @returns The cached response or null if not found\n     */\n    async match(request: Request, cacheOptions?: CloudflareHelper.CacheOptions): Promise<Response | null> {\n\n        // Build cache key\n        const cacheKey = this.buildCacheKey(request, cacheOptions?.normalizeKey);\n        if (!cacheKey) {\n            return null;\n        }\n\n        // Check if the request is in cache\n        const hit:Response = await this.#cache.match(cacheKey) as Response;\n        if(hit) {\n            // Set x-cache header to indicate cache hit\n            return this.updateHeaders(hit, { 'x-cache': 'HIT' });\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Takes a request and response and caches the response\n     * The Response headers can be modified before caching via cacheOptions\n     * Waits until the caching is complete before returning\n     * @param request \n     * @param response \n     * @param cacheOptions \n     * @returns \n     */\n    async put(request: Request, response: Response, cacheOptions?: CloudflareHelper.CacheOptions): Promise<Response> {\n        // Build cache key\n        const cacheKey = this.buildCacheKey(request, cacheOptions?.normalizeKey);\n        if (!cacheKey) {\n            throw new Error('Invalid cache key');\n        }\n\n        // Set headers if provided\n        if (cacheOptions?.headers) {\n            // Create a new Response with updated headers\n            response = this.updateHeaders(response, cacheOptions.headers);\n        }\n\n        // Put the response in cache\n        // Use waitUntil to avoid blocking the response\n        this.getContext().waitUntil(\n            this.#cache.put(cacheKey, response.clone())\n        );\n        return response;\n    }\n\n    /**\n     * Deletes a cached response based on the provided request or URL\n     * @param deleteRequestOrURL - The Request, URL, or string URL to delete from cache\n     * @param cacheOptions - Optional cache options for key normalization and base request\n     * @returns A promise that resolves to true if the cached response was deleted, false otherwise\n     */\n    async delete(deleteRequestOrURL: Request | URL | string, cacheOptions?: CloudflareHelper.CacheOptions): Promise<boolean> {\n\n        // Check deleteRequestOrURL type and create Request\n        let deleteRequestUrl: string =  deleteRequestOrURL instanceof Request ?\n            deleteRequestOrURL.url :\n            deleteRequestOrURL instanceof URL ?\n                deleteRequestOrURL.toString() :\n                deleteRequestOrURL;\n       \n        // Check for absolute URL\n        const pattern = /^https?:\\/\\//i;\n        if(!pattern.test(deleteRequestUrl)) {\n            if(cacheOptions?.baseRequest) {\n                deleteRequestUrl = new URL(deleteRequestUrl, cacheOptions.baseRequest.url).toString();\n            } else {\n                throw new Error('Base URL is required for relative delete URL');\n            }\n        }\n\n        // Check for method in cacheOptions\n        const method = cacheOptions?.method ?? 'GET';\n\n        // Build Request for deletion\n        const deleteRequest = new Request(deleteRequestUrl, { method: method });\n    \n        // Build cache key\n        const cacheKey = this.buildCacheKey(deleteRequest, cacheOptions?.normalizeKey);\n\n        if (cacheOptions?.debug) {\n            console.debug('[cache.delete]', cacheKey.method, cacheKey.url);\n        }\n\n        // Delete the cached response\n        const deleted = await this.#cache.delete(cacheKey);\n        return deleted;\n    }\n}\n\n/**\n * Cloudflare R2 Storage Helper\n * This class provides methods to interact with R2 buckets.\n */\nexport class CFR2 extends CloudflareBase {\n    // R2 limits\n    private static readonly MAX_METADATA_SIZE = 8192; // 8KB\n    private static readonly MAX_KEY_LENGTH = 1024;\n\n    constructor(platform: Readonly<CloudflareHelper.Platform>) {\n        super(platform);\n    }\n\n    /**\n     * Validates bucket name\n     * @param bucketName - Name of the bucket to validate\n     * @throws Error if bucket name is invalid\n     */\n    private validateBucketName(bucketName: string): void {\n        if (!bucketName || typeof bucketName !== 'string') {\n            throw new Error('Bucket name must be a non-empty string');\n        }\n        if (bucketName.trim().length === 0) {\n            throw new Error('Bucket name cannot be empty');\n        }\n    }\n\n    /**\n     * Validates object key\n     * @param key - Key to validate\n     * @throws Error if key is invalid\n     */\n    private validateKey(key: string): void {\n        if (!key || typeof key !== 'string') {\n            throw new Error('Key must be a non-empty string');\n        }\n        if (key.length > CFR2.MAX_KEY_LENGTH) {\n            throw new Error(`Key length cannot exceed ${CFR2.MAX_KEY_LENGTH} characters`);\n        }\n    }\n\n    /**\n     * Validates metadata size\n     * @param metadata - Metadata object to validate\n     * @throws Error if metadata exceeds size limit\n     */\n    private validateMetadata(metadata: Record<string, string>): void {\n        const metadataSize = JSON.stringify(metadata).length;\n        if (metadataSize > CFR2.MAX_METADATA_SIZE) {\n            throw new Error(`Metadata size (${metadataSize} bytes) exceeds limit of ${CFR2.MAX_METADATA_SIZE} bytes`);\n        }\n    }\n    \n    getBucket(bucketName: string): R2Bucket | null {\n        this.validateBucketName(bucketName);\n        return this.getBinding<R2Bucket>(bucketName);\n    }\n  \n    getBucketNames() {\n        const bucketNames: CloudflareHelper.R2BucketInfo[] = [];\n        const env = this.getEnv();\n        \n        for (const [key, value] of Object.entries(env)) {\n            // Check if the value is an R2Bucket instance\n            if (value && typeof value === 'object' && 'get' in value && 'put' in value) {\n                bucketNames.push({ name: key });\n            }\n        }\n        return bucketNames;\n    }\n\n    async getBucketData(bucket: string, key: string): Promise<R2ObjectBody | null> {\n        this.validateBucketName(bucket);\n        this.validateKey(key);\n        \n        const R2Bucket = this.getBucket(bucket);\n        if (!R2Bucket) {\n            throw new Error(`Bucket '${bucket}' not found`);\n        }\n        return await R2Bucket.get(key);\n    }\n\n    //setMetadata(R2Object: R2Object, headers: Record<string, string>) {\n    //    const _headers = new CFHeaders();\n    //    R2Object?.writeHttpMetadata(_headers);\n    //    for (const [key, value] of Object.entries(headers)) {\n    //        _headers.set(key, value);   \n    //    }\n    //    return _headers;\n    //}\n\n    createUniqueKey(file: File, useFileName=true) {\n        // Generate unique key\n        const timestamp = Date.now();\n        const extension = file.name.split('.').pop() || 'jpg'; // maybe not good; throw error?\n        const name = file.name.split('.').slice(0, -1).join('.');\n        let keyPart = name;\n        if(!useFileName) {\n            keyPart = crypto.randomUUID().substring(0, 8);\n        }\n        const key = `${timestamp}-${keyPart}.${extension}`;\n        return key;\n    }\n\n    setHttpMetadata(metadata: R2HTTPMetadata ) {\n        let httpMetadata: Record<string, string>= {};\n        httpMetadata['contentType'] = metadata.contentType || 'application/octet-stream';\n        if(metadata.cacheControl) {\n            httpMetadata['cacheControl'] = metadata.cacheControl;\n        }\n        if(metadata.contentDisposition) {\n            httpMetadata['contentDisposition'] = metadata.contentDisposition;\n        }\n        if(metadata.contentLanguage) {\n            httpMetadata['contentLanguage'] = metadata.contentLanguage;\n        }\n        if(metadata.contentEncoding) {\n            httpMetadata['contentEncoding'] = metadata.contentEncoding;\n        }\n        return httpMetadata;\n    }\n\n    setCustomMetadata(metadata: CloudflareHelper.CustomMetadata) {\n        let customMetadata: Record<string, string>= {};\n        customMetadata['originalFileName'] = metadata.file.name;\n        customMetadata['uploadedBy'] = metadata.userId || 'anonymous';\n        customMetadata['uploadedAt'] = new Date().toISOString();\n        customMetadata['fileSize'] = metadata.file.size.toString();\n        customMetadata['mimeType'] = metadata.file.type;\n        customMetadata['category'] = metadata.category || 'general';\n        customMetadata['processed'] = metadata.processed || 'false';\n        customMetadata['thumbnailGenerated'] = metadata.thumbnailGenerated || 'false';\n\n        // Validate metadata size\n        this.validateMetadata(customMetadata);\n        \n        return customMetadata;\n    }\n\n    async listBucketData(name: string, options: R2ListOptions): Promise<{\n        objects: R2Object[];\n        cursor: string | undefined;\n        hasMore: boolean;\n    }> {\n        this.validateBucketName(name);\n        \n        const bucket = this.getBucket(name);\n        if (!bucket) {\n            throw new Error(`Bucket '${name}' not found`);\n        }\n\n        const listed = await bucket.list(options);\n        let truncated = listed.truncated;\n        let cursor: string | undefined = truncated ? (listed as R2Objects & { cursor?: string }).cursor : undefined;\n        \n        while (truncated && cursor) {\n            const next = await bucket.list({ ...options, cursor });\n            listed.objects.push(...next.objects);\n            truncated = next.truncated;\n            cursor = truncated ? (next as R2Objects & { cursor?: string }).cursor : undefined;\n        }\n        \n        return {\n            objects: listed.objects,\n            cursor: cursor,\n            hasMore: truncated\n        };\n    }\n}"]}